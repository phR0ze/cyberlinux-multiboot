#!/bin/bash
#MIT License
#Copyright (c) 2017-2021 phR0ze
#
#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.

# Booting Linux Systems:
# http://archlinux.me/brain0/2010/02/13/early-userspace-in-arch-linux/
# -----------------------------------------------------------------------------
# BIOS Firmware
# BIOS looks for a partition on the primary disk that contains the Master Boot
# Record (MBR) and loads the boot manager from there (e.g. Syslinux/ISOlinux)
# which in turn loads the chosen Linux kernel and initramfs (early userspace)
# which then bootstraps then bootstraps the system to the point where it can
# access the real root filesystem at which point the initramfs turns control
# over to systemd to complete the boot process.
#
# UEFI Firmware
# UEFI firmware identifies the ESP (i.e. partition with code ef00 formatted as
# FAT) and loads the binary at /EFI/BOOT/BOOTx86.efi which can be either a boot
# manager or bootloader. Either way the binary loads the target kernel or target
# bootloader which loads the target kernel
# -----------------------------------------------------------------------------
none="\e[m"
red="\e[1;31m"
cyan="\e[0;36m"

exit_to_shell()
{
    alias ll='ls -lah'
    export PS1="${cyan}[rootfs:\w]\$ ${none}"
    echo -e "\n${cyan}:: Interactive Shell${none}"
    launch_interactive_shell
}

fail_to_shell()
{
    echo -e "${red}failed!${none}"
    launch_interactive_shell
}

check_status()
{
    if [ $? -ne 0 ]; then
        fail_to_shell
    else
        [ "$1" != "nomsg" ] && echo -e "${cyan}success!${none}"
    fi
}

# Get a simple user input
getinput()
{
    local _result=$1                                # Return value container
    local input=$2                                  # User input value to prompt for
    local result=$3                                 # Default value to use if not set
    local silent=$4                                 # Don't echo when set

    echo -en "   ${input} (default=${cyan}${result}${none}): "
    [ "x$DEFAULT" == "xy" ] && echo ''
    if [ "x$DEFAULT" == "xn" ]; then
        if [ $silent ]; then
            read -s value
            echo ''
        else
            read value
        fi
        [ "$value" == "exit" ] && exit_to_shell
        [ "x$value" != "x" ] && local result=$value
    fi

    eval $_result=$result
}

getsel()
{
    local _result=$1                                # Return value container
    local options=$2                                # Space separate options

    local result=''
    local out_of_bounds=1
    for x in $options; do
        local out_of_bounds=$(($out_of_bounds+1))
    done
    while true; do
        echo -en "   Enter a number (default=${cyan}1${none}): "
        [ "x$DEFAULT" == "xy" ] && echo '' || read choice
        [ "$choice" == "exit" ] && exit_to_shell
        [ "x$choice" == "x" ] && choice=1
        if [ $choice -gt 0 ] && [ $choice -le $out_of_bounds ]; then
            local result=$(echo $options | awk "{print \$$choice}")
            break
        else
            echo -e "   ${red}Invalid selection, please try again${none}"
       fi
    done

    eval $_result=$result
}

mount_layers()
{
    local images_path=$1                            # e.g. ${ISO_MNT}/images
    local layered_mnt=$2                            # e.g. ${WRITE_MNT}/root
    local layered_tmp=$3                            # e.g. ${WRITE_MNT}/temp

    # Mount all implicated sqfs images
    local layer_dirs=""
    echo -e ":: Mounting implicated layers"
    for x in ${layers//,/ }; do
        local img_mnt="${READ_MNT}/${x}"             # i.e. ${READ_MNT}/{base,devel,lite, etc...}
        local img_path="${images_path}/${x}.sqfs"   # e.g. ${ISO_MNT}/images/base.sqfs
        layer_dirs="${layer_dirs}${img_mnt}:"

        echo -en ":: Detecting presence of layer ${img_path}..."
        if [ ! -f ${img_path} ]; then
            echo -e "${red}failed!${none}"
            echo -e ":: ${red}Please build and include the missing deployment layer!${none}\n"
            launch_interactive_shell
        else
            [ "$1" != "nomsg" ] && echo -e "${cyan}success!${none}"
        fi

        echo -en ":: Mounting ${img_path} at ${img_mnt}..."
        mkdir -p "${img_mnt}"
        mount -r -t squashfs ${img_path} ${img_mnt} &>/dev/null
        check_status
        MOUNTS="${MOUNTS}${img_mnt} "
    done
    layer_dirs=${layer_dirs%?}

    # Layer squashfs images as implicated by $(layers)
    # e.g. new writable root = (live,heavy,lite,devel,base)
    echo -en ":: Overlay squashfs layers ${layer_dirs}..."
    mkdir -p ${layered_mnt}
    mkdir -p ${layered_tmp}
    mount -t overlay -o lowerdir=${layer_dirs},upperdir=${layered_mnt},workdir=${layered_tmp} none ${layered_mnt}
    check_status
    MOUNTS="${MOUNTS}${layered_mnt} "
}

# Wait for install device to register with system then mount it.
# Use wellknown install device label to detect its existance
mount_install_device()
{
    echo -en ":: Locating install device labeled ${LABEL}..."

    local i=0
    local success=0
    while [ $success -eq 0 ]; do
        sleep 0.25 # Sleep for a bit

        # Find device by label
        ISODEV=$(blkid -L ${LABEL}) &>/dev/null
        if [ "x${ISODEV}" != "x" ]; then
            check_status

            # Get install device file system type for mount
            local fstype=$(blkid -s TYPE -o value ${ISODEV}) &>/dev/null

            # Trim partition off if not iso to get media type
            # /dev/sda3 to /dev/sda in USB case
            # /dev/sr0 in CD/ISO case
            local isodev=$ISODEV
            if [ "x${fstype}" != "xiso9660" ]; then
                isodev=${ISODEV%?}
            fi

            # Using base iso device get device type and trim to first word
            local install_type=$(echo $(lsblk -nl -o TYPE ${isodev})) &>/dev/null
            install_type=${install_type%% *}

            # Mount iso device found by label with correct fstype
            echo -en "   Mounting install ${cyan}${install_type}${none} [${cyan}${ISODEV}${none}] to ${ISO_MNT}..."
            mount -r -t ${fstype} -o noatime ${ISODEV} ${ISO_MNT} &>/dev/null
            check_status && success=1
        fi

        # Timeout if takes more than 10 seconds
        let "i+1"
        [ $i -eq 40 ] && fail_to_shell
    done
}

# Partition disk and mount for install at ${rootmnt}
partition_and_mount_disk()
{
    # Wipe, partition and format disk
    #---------------------------------------------------------------------------
    echo -en ":: Disk ${cyan}${INSTALL_DEV}${none} identified as install disk..."
    [ "x${INSTALL_DEV}" != "x" ]
    check_status

    echo -en ":: Destroy any magic strings and/or signatures on ${INSTALL_DEV}..."
    wipefs --all --force ${INSTALL_DEV} &>/dev/null
    check_status

    echo -en ":: Wiping partition table on ${INSTALL_DEV}..."
    sgdisk --zap ${INSTALL_DEV} &>/dev/null
    check_status

    # Set partition identifiers
    if [ "x${SSD}" == "x1" ]; then
        part_boot="${INSTALL_DEV}p1"
        part_swap="${INSTALL_DEV}p2"
        part_root="${INSTALL_DEV}p3"
    else
        part_boot="${INSTALL_DEV}1"
        part_swap="${INSTALL_DEV}2"
        part_root="${INSTALL_DEV}3"
    fi

    # EFI: Create a GPT boot disk
    # https://wiki.archlinux.org/index.php/EFI_System_Partition#Create_the_partition
    if [ "x${EFI}" == "x1" ]; then

        # Create ESP boot partition
        echo -en ":: Creating ${part_boot} as ESP boot partition..."
        sgdisk -n 0:0:+512M -t 0:EF00 -c 0:"EFI System" ${INSTALL_DEV} &>/dev/null
        check_status
        echo -en ":: Formatting ${part_boot} (ESP) as FAT..."
        mkfs.fat -n "ESP" ${part_boot} &>/dev/null
        check_status

        # Create SWAP partition
        echo -en ":: Creating ${part_swap} as Linux swap partition..."
        sgdisk -n 0:0:+4G -t 0:8200 -c 0:"Linux swap" ${INSTALL_DEV} &>/dev/null
        check_status

        # Create root partition and set boot flag
        echo -en ":: Creating ${part_root} as Linux filesystem partition..."
        sgdisk -n 0:0:0 -t 0:8300 -c 0:"Linux filesystem" ${INSTALL_DEV} &>/dev/null
        check_status
        echo -en ":: Setting boot flag on ${INSTALL_DEV}..."
        sgdisk ${INSTALL_DEV} --attributes=3:set:2 &>/dev/null
        check_status

    # BIOS: Create a MBR boot disk
    else
        echo -en ":: Partitioning ${INSTALL_DEV} with MBR..."
        echo ',2M,0' > layout
        echo ',4G,82' >> layout
        echo ',+,83,*' >> layout
        cat layout | sfdisk ${INSTALL_DEV} &>/dev/null
        check_status
        rm -f layout
    fi

    # Configure swap partition
    echo -en ":: Formatting ${part_swap} as (swap)..."
    mkswap -L SWAP ${part_swap} &>/dev/null
    check_status
    echo -en ":: Starting swap on ${part_swap}..."
    swapon ${part_swap} &>/dev/null
    check_status

    echo -en ":: Formatting ${part_root} as (ext4)..."
    # -F            force creation even if some params don't make sense
    # -L            set volume name to 'cyberlinux' used by bootloaders
    # -m 0          don't reserve blocks for super user daemons
    # -q            run in quiet mode for scripts
    mkfs.ext4 -F -m 0 -q -L ${LABEL} ${part_root} &>/dev/null
    check_status

    # Mount root as rootmnt and disable access time writes (speeds things up)
    echo -en ":: Mounting ${part_root} as ${rootmnt}..."
    mount -o noatime ${part_root} ${rootmnt} &>/dev/null
    check_status

    # Mount the ESP on top of the root at /boot
    if [ "x${EFI}" == "x1" ]; then
        mkdir -p $rootmnt/boot
        mount ${part_boot} $rootmnt/boot
    fi
}

# GRUB has the ability to set the gfxmode and have the kernel keep it
# https://wiki.archlinux.org/index.php/GRUB
# https://blog.heckel.xyz/2017/05/28/creating-a-bios-gpt-and-uefi-gpt-grub-bootable-linux-system/
install_bootloader()
{
    platform=x86_64-efi
    esp_mnt=${rootmnt}/mnt
    grub_path=${rootmnt}/mnt/grub

    # Prepare GRUB (/new_root/boot/grub), EFI (/new_root/mnt/boot/grub)
    #---------------------------------------------------------------------------
    if [ "x${EFI}" == "x1" ]; then
        echo -en ":: Mount ${part_boot} (ESP) as ${esp_mnt}..."
        mount ${part_boot} ${esp_mnt} &>/dev/null
        check_status
        rm -rf ${rootmnt}/boot/grub
    else
        platform=i386-pc
        grub_path=${rootmnt}/boot/grub
    fi

    # Install GRUB bootloader to the MBR on i386-pc and ESP for EFI system
    # grub-install populates the $grub_path with everything needed to boot
    # the system, all we need is to customize the 'grub.cfg'
    #---------------------------------------------------------------------------
    shared_modules="ext2 all_video font gfxterm"
    if [ "x${EFI}" == "x1" ]; then
        echo -en ":: Create GRUB bootloader path ${esp_mnt}/EFI/BOOT..."
        mkdir -p ${esp_mnt}/EFI/BOOT &>/dev/null
        check_status

        # Arch Linux standard ESP mount point is /boot used for kernel upgrades
        # Tianocore UEFI only supports fallback location EFI/BOOT/BOOTX64.efi
        # /grub is used as the target as this is in the context of the partition
        echo -en ":: Install GRUB bootloader to ${bootloader}..."
        chroot ${rootmnt} grub-mkimage -d /mnt/grub/${platform} -o /mnt/EFI/BOOT/BOOTX64.efi \
            -O ${platform} -p /grub part_gpt fat efi_gop efi_uga ${shared_modules} &>/dev/null
        check_status
    else
        echo -en ":: Install GRUB BIOS bootloader to ${INSTALL_DEV}..."
        chroot ${rootmnt} grub-install --target=${platform} \
            --modules="part_msdos ${shared_modules}" ${INSTALL_DEV} &>/dev/null
        check_status
    fi

    # Install custom GRUB configuration file 'grub.cfg' to the ESP for EFI
    # or /boot/grub for BIOS# which is read by GRUB once it has booted up.
    echo -en ":: Install GRUB config at ${grub_path}..."
    echo -e "default=0\ntimeout=0\n" > ${grub_path}/grub.cfg
    echo -e 'set gfxmode="<%=gfxmode%>"' >> ${grub_path}/grub.cfg
    echo -e 'loadfont fonts/unicode.pf2' >> ${grub_path}/grub.cfg
    echo -e 'terminal_input console' >> ${grub_path}/grub.cfg
    echo -e "terminal_output gfxterm\n" >> ${grub_path}/grub.cfg
    echo -e "menuentry \"${LABEL}\" {" >> ${grub_path}/grub.cfg
    echo -e "    set gfxpayload=keep" >> ${grub_path}/grub.cfg
    echo -e "    search --no-floppy --set=root --label ${LABEL}" >> ${grub_path}/grub.cfg
    echo -e "    linux /boot/vmlinuz-${KERNEL} root=LABEL=${LABEL} rw <%=kernel_params%>" >> ${grub_path}/grub.cfg
    echo -e "    initrd /boot/intel-ucode.img /boot/initramfs-${KERNEL}.img" >> ${grub_path}/grub.cfg
    echo -e "}" >> ${grub_path}/grub.cfg
    check_status

    # Unmount ESP if EFI mode
    if [ "x${EFI}" == "x1" ]; then
        echo -en ":: Umount ${part_boot} (ESP) at ${esp_mnt}..."
        umount -f ${esp_mnt} &>/dev/null
        check_status
    fi

    echo -en ":: Generate new initramfs specific to this machine..."
    chroot ${rootmnt} mkinitcpio -p $KERNEL &>/dev/null
    check_status
}

mount_chroot_dirs()
{
    # Ensure mount point directories exist
    for x in "sys proc dev dev/pts"; do
        mkdir -p ${rootmnt}/${x} &>/dev/null
    done

    # Mount current system in newchroot
    mount -t sysfs sysfs ${rootmnt}/sys &>/dev/null
    mount -t proc /proc ${rootmnt}/proc &>/dev/null
    mount -o bind /dev ${rootmnt}/dev &>/dev/null
    mount -t devpts /dev/pts ${rootmnt}/dev/pts &>/dev/null
}

umount_chroot_dirs()
{
    for x in "sys proc dev/pts dev"; do
        umount -f ${rootmnt}/${x} &>/dev/null
    done
}

umount_all()
{
    MOUNTS="${MOUNTS}${ISO_MNT}"
    for x in ${MOUNTS}; do
        echo -en ":: Unmounting ${x}..."
        umount -f ${x} &>/dev/null
        check_status
    done
}

config_system()
{
    echo -en ":: Set root user password..."
    chroot ${rootmnt} usermod -p ${PASS} root
    check_status

    # Filter groups down to just those that exist
    local groups=""
    for x in ${ALL_GROUPS//,/ }; do
        if [ $(grep -E "^$x:" ${rootmnt}/etc/group) ]; then
            [ $groups ] && groups="${groups},${x}" || groups="${x}"
        fi
    done

    # Configure wifi before user is created to pick up autostart
    if [ "x$ENABLE_WIFI" == "x1" ]; then
        echo -en ":: Enable Wifi..."
        chroot ${rootmnt} cp /usr/share/applications/wpa_gui.desktop /etc/skel/.config/autostart &>/dev/null
        chroot ${rootmnt} ln -sf /usr/lib/systemd/system/wpa_supplicant@.service /etc/systemd/system/multi-user.target.wants/wpa_supplicant@wlo1.service &>/dev/null
        check_status
    fi

    echo -en ":: Create user group '${USER}'..."
    chroot ${rootmnt} groupadd ${USER}
    check_status

    echo -en ":: Create user '${USER}' with groups '${groups}'..."
    chroot ${rootmnt} useradd -m -g ${USER} -G ${groups} -s /bin/bash ${USER}
    check_status

    echo -en ":: Set user password..."
    chroot ${rootmnt} usermod -p ${PASS} ${USER}
    check_status

    echo -en ":: Add new user to sudoers list..."
    chroot ${rootmnt} /bin/bash -c "echo '${USER} ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers"
    check_status

    # Set hostname to chosen layer
    echo -en ":: Set hostname to ${HOSTNAME}..."
    echo $HOSTNAME > "${rootmnt}/etc/hostname"
    check_status

    # Configure timezone
    echo -en ":: Set timezone to ${TIMEZONE}..."
    chroot ${rootmnt} ln -sf /usr/share/zoneinfo/$TIMEZONE /etc/localtime &>/dev/null
    check_status

    # Configure networking
    # https://www.freedesktop.org/software/systemd/man/systemd.network.html#
    netmatch='en* eth*'
    if [ "x${NETIP}" != "xDHCP" ]; then
        # Static LAN
        local conf="${rootmnt}/etc/systemd/network/10-static.network"
        echo -en ":: Configuring static networking..."
        echo -e "[Match]\nName=${netmatch}\n" > $conf
        echo -e "[Network]\nAddress=${NETIP}\nGateway=${gateway}\nDNS=${DNS1}\nDNS=${DNS2}" >> $conf
        echo -e "IPForward=kernel" >> $conf
        check_status
    else
        # DHCP LAN
        local conf="${rootmnt}/etc/systemd/network/20-dhcp.network"
        echo -en ":: Configuring dhcp networking..."
        echo -e "[Match]\nName=${netmatch}\n" > $conf
        echo -e "[Network]\nDHCP=ipv4\nIPForward=kernel\n" >> $conf
        echo -e "[DHCP]\nUseDomains=true" >> $conf
        check_status
    fi

    # DHCP Wireless
    local conf="${rootmnt}/etc/systemd/network/30-wireless.network"
    echo -en ":: Configuring dhcp wireless networking..."
    echo -e "[Match]\nName=wl*\n" > $conf
    echo -e "[Network]\nDHCP=ipv4\nIPForward=kernel\n" >> $conf
    echo -e "[DHCP]\nRouteMetric=20\nUseDomains=true" >> $conf
    check_status

    if [ $PROXY ] && [ "x$PROXY" != "xNone" ]; then
        echo -en ":: Set PROXY to ${PROXY}..."
        if [ $NO_PROXY ] && [ "x$NO_PROXY" != "xNone" ]; then
            chroot ${rootmnt} /opt/$DISTRO/bin/setproxy enable $PROXY $NO_PROXY &>/dev/null
        else
            chroot ${rootmnt} /opt/$DISTRO/bin/setproxy enable $PROXY &>/dev/null
        fi
        check_status
    fi

    # Configure root access for sshd if default deployment
    if [ -e "${rootmnt}/etc/ssh/sshd_config" ]; then
        if [ "x$DEFAULT" == "xy" ]; then
            echo -en ":: Enable sshd root access for default..."
            sed -i -e 's/^PermitRootLogin.*/PermitRootLogin yes/' "${rootmnt}/etc/ssh/sshd_config"
            check_status
        fi
    fi

    # Autologin if lxdm exists and parameter is set
    if [ -e "${rootmnt}/etc/lxdm/lxdm.conf" ]; then
        if [ "x$AUTOLOGIN" == "x1" ]; then
            echo -en ":: Enable autologin for LXDM..."
            sed -i -e "s/^#\s*autologin=.*/autologin=${USER}/" "${rootmnt}/etc/lxdm/lxdm.conf"
            check_status
        fi
    fi
}

# Create a new system mount then overlay layers as specified
# called by initcpio system with /new_root as param
installer()
{
    # Welcome message, centered
    #---------------------------------------------------------------------------
    local msg="--===<<<[[ ${LABEL} ]]>>>===--"
    local len=$((105 - ${#msg}))
    local padleft=$(bash -c "printf '%0.1s' ' '{1..$((len/2))} $pad")
    local padright=$(bash -c "printf '%0.1s' ' '{1..$((len/2))} $pad")
    [ $((len%2)) == 1 ] && local padright="$padright "
    echo -e "${cyan}:: $(bash -c "printf '%0.1s' '*'{1..107}")${none}"
    echo -e "${cyan}:: *${padleft}${msg}${padright}*${none}"
    echo -e "${cyan}:: $(bash -c "printf '%0.1s' '*'{1..107}")${none}"
    echo -e "   ${PARAMS}"

    # Mount install source device
    #---------------------------------------------------------------------------
    mount_install_device

    # Set defaults for live and default deployments
    #---------------------------------------------------------------------------
    SSD=0
    DEFAULT="n"
    ENABLE_WIFI=0
    HOSTNAME="${DISTRO}-${LAYER//\//-}"
    NETIP='DHCP'
    PROXY='None'
    NO_PROXY='localhost,127.0.0.1'
    USER='admin'
    PASS=$(mkpasswd -m sha "admin")

    # Ask for user input if not live deployment
    #---------------------------------------------------------------------------
    if [ "$LAYER" != 'live' ]; then

        # Read in the destination disk options to present to the user
        DISKS_DETAILED=$(lsblk -dn -o NAME,SIZE,MODEL,TYPE -x NAME --json | \
            jq -rc '[.blockdevices[]|select(.type=="disk")]')
        DISKS=$(echo ${DISKS_DETAILED} | jq -rc '[.[].name]|map("/dev/"+.)')
        INSTALL_DEV="/dev/$(echo ${DISKS_DETAILED} | jq -rc '.[0].name')"

        # Determine if this is a default deployment
        echo -e "\n${cyan}:: Automatically deploy with defaults?${none}"
        getinput DEFAULT 'Use automatic mode with defaults' 'n'
        if [ "x$DEFAULT" == "xy" ]; then
            AUTOLOGIN=1
            echo -e "\n${cyan}:: Automatic deployment mode selected...${none}"
            echo -e "   hostname=${HOSTNAME}"
            echo -e "   networking=${NETIP}"
            echo -e "   proxy=${PROXY}"
            echo -e "   no_proxy=${NO_PROXY}"
            echo -e "   user=${USER}"
            echo -e "   pass=admin"
            echo -e "   install_dev=${INSTALL_DEV}"
        else
            # Collect install destination device
            #-----------------------------------------------------------------------
            echo -e "\n${cyan}:: Select a disk as your install destination:${none}"
            local i=0
            echo $DISKS_DETAILED | jq -rc '.[]' | while read x; do
                i=$((i+1))
                local disk="/dev/$(echo $x | jq -r '.name')"
                local size="$(echo $x | jq -r '.size')"
                local model="$(echo $x | jq -r '.model')"
                echo -e "   ${i}) [${cyan}${disk}${none}](${cyan}${size}${none}) - ${model}"
            done
            getsel INSTALL_DEV "$DISKS"

            # Determine the type of storage from the three most common types:
            # SSD type storage either NVMe or MMC both use a similar partition naming
            # convention so we really only need to determine if its not an HDD.
            # SCSI: /dev/sda        partition1: /dev/sda1
            # NVMe: /dev/nvme0n1    partition1: /dev/nvme0n1p1
            # MMC: /dev/mmcblk0     partition1: /dev/mmcblk0p1
            [ ${INSTALL_DEV//sda} != "/dev/" ] && SSD=1

            # Configure networking
            #----------------------------------------------------------------------
            echo -e "\n${cyan}:: Configure networking:${none}"
            getinput HOSTNAME 'Enter hostname' $HOSTNAME
            getinput NETIP 'Enter static IP, e.g. 192.168.1.2/24' 'DHCP'
            if [ "x${NETIP}" != "xDHCP" ]; then
                getinput gateway 'Enter gateway' $(echo $NETIP | awk -F. '{print $1"."$2"."$3".1"}')
            fi
            getinput PROXY 'Enter proxy, url:port format' $PROXY
            [ "x${PROXY}" != "xNone" ] && getinput NO_PROXY 'Enter no_proxy, comma delim' $NO_PROXY
            getinput ENABLE_WIFI 'Enter wifi state' 0

            # Configure timezone
            #----------------------------------------------------------------------
            echo -e "\n${cyan}:: Configure timezone:${none}"
            getinput TIMEZONE 'Enter timezone' $TIMEZONE

            # Create new user account
            #----------------------------------------------------------------------
            echo -e "\n${cyan}:: Create new user account:${none}"
            getinput USER 'Enter new username' $USER
            while true; do
                getinput PASS 'Enter new password' 'admin' 1
                getinput PASS2 'Enter password again' 'admin' 1
                if [ "x$PASS" != "x$PASS2" ]; then
                    echo -e "   ${red}Passwords don't match, please try again${none}"
                else
                    break
               fi
            done
            PASS=$(mkpasswd -m sha $PASS)

            # Prompt for autologin
            if [ "x$AUTOLOGIN" != "x1" ]; then
                getinput autologin 'Enter autologin' 0
            fi
        fi
    fi

    # Mount live system / Install to local disk
    #---------------------------------------------------------------------------
    rootmnt="${1}"                          # /new_root passed in as 1st param
    local rw_ram_size="75%"
    local mode=$([ "$LAYER" == 'live' ] && echo 'Starting' || echo 'Installing')
    echo -e "\n${cyan}:: ${mode} '${LAYER}' system with layers '${layers}'${none}"
    echo -e "${cyan}:: --------------------------------------------------------------------${none}"
    echo -e ":: New Root path '${rootmnt}'"
    if [ $LAYER == "live" ]; then
        echo -en ":: Creating live tmpfs filesystem for writes, size=${rw_ram_size}..."
        mount -t tmpfs -o "size=${rw_ram_size}",mode=0755 none ${WRITE_MNT} &>/dev/null
        check_status
        mount_layers "${ISO_MNT}/images" ${WRITE_MNT}/root ${WRITE_MNT}/temp

        echo -en ":: Re-bind ${WRITE_MNT}/root to new root location ${rootmnt}..."
        mount -o bind ${WRITE_MNT}/root ${rootmnt} &>/dev/null
        check_status
    else
        # Copies /mnt/read/root/ to /new_root
        mount_layers "${ISO_MNT}/images" ${READ_MNT}/root ${READ_MNT}/temp
        partition_and_mount_disk
        echo -e ":: Copying ${READ_MNT}/root to ${rootmnt}"
        rsync -ah --info=progress2 ${READ_MNT}/root/* ${rootmnt}
    fi

    # Configure system
    #---------------------------------------------------------------------------
    mount_chroot_dirs
    config_system
    echo -en ":: Set unique machine-id..."
    chroot ${rootmnt} dbus-uuidgen --ensure=/etc/machine-id &>/dev/null
    chroot ${rootmnt} ln -sf /etc/machine-id /var/lib/dbus/machine-id &>/dev/null
    check_status

    # Install bootloader and initramfs
    #---------------------------------------------------------------------------
    if [ $LAYER != "live" ]; then
        install_bootloader
    fi
    umount_chroot_dirs

    # Unmount everything after install
    [ $LAYER != "live" ] && umount_all

    # Successfully deployed
    #---------------------------------------------------------------------------
    if [ $LAYER != "live" ]; then
        local msg="--===<<<[[ SUCCESS ]]>>>===--"
        local len=$((105 - ${#msg}))
        local padleft=$(bash -c "printf '%0.1s' ' '{1..$((len/2))} $pad")
        local padright=$(bash -c "printf '%0.1s' ' '{1..$((len/2))} $pad")
        [ $((len%2)) == 1 ] && local padright="$padright "
        echo -e "${cyan}:: $(bash -c "printf '%0.1s' '*'{1..107}")${none}"
        echo -e "${cyan}:: *${padleft}${msg}${padright}*${none}"
        echo -e "${cyan}:: $(bash -c "printf '%0.1s' '*'{1..107}")${none}"

        # Eject media and reboot
        [ "x$DEFAULT" != "xy" ] && eject &>/dev/null
    fi
}

#----------------------------------------------------------------------------------------
# Early user space hook
#----------------------------------------------------------------------------------------
run_hook()
{
    # Set cmdline params as variables to use during install
    PARAMS=$(cat /proc/cmdline)
    for x in ${PARAMS}; do
        case "${x}" in
            'kernel'=*) KERNEL=${x//kernel=} ;;
            'layers'=*) LAYERS=${x//layers=} ;;
            'autologin'=*) AUTOLOGIN=${x//autologin=} ;;
            *) continue ;;
        esac
    done

    # Set additional variables
    MOUNTS=""
    ISO_MNT=/mnt/iso
    READ_MNT=/mnt/read
    WRITE_MNT=/mnt/write

    # Variables
    LABEL="CYBERLINUX_INSTALLER"
    DISTRO="cyberlinux"
    TIMEZONE="America/Boise"
    ALL_GROUPS="lp,wheel,network,storage,users,video,audio,adbusers,uucp,docker"
    DNS1="1.1.1.1"
    DNS2="1.0.0.1"
    EFI=0

    # Get the last layer which will be our target
    LAYER=$(echo $LAYERS | awk -F, '{print $NF}')

    # Default autologin if live is the target layer
    [ "$LAYER" == "live" ] && AUTOLOGIN=1

    # Custom handler defined above.
    mount_handler="installer"
}

# vim: ft=sh:ts=4:sw=4:sts=4
